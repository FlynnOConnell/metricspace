{\rtf1\ansi\ansicpg1252\deff0\deflang1033{\fonttbl{\f0\fnil\fcharset0 Calibri;}}
{\*\generator Msftedit 5.41.21.2510;}\viewkind4\uc1\pard\sa200\sl276\slmult1\lang9\f0\fs22 function d=spkdl(stime,sstart,send,cost)\par
%SPKDL. Calculates the "spike time" distance matrix at fixed cost. (MEX file version.)\par
% D=SPKDL(STIME,SSTART,SEND,COST). Calculates the full distance matrix for the "spike time" metric\par
%  (Victor & Purpura 1996) for a single cost. Compiled as a MEX file (SPKDL.DLL) on Windows NT, but\par
%  compilation seems to work on Windows 98 and Windows 2000 platforms.\par
%\par
%  STIME\tab       list of spike times (row vector)\par
%  SSTART      list of trial start indices (row vector, length: # stimulus XMPsentations)\par
%  SEND        list of trial end indices (row vector, length: same as SSTART); if a trial has no\par
%               spikes in it, the SEND value should be one less than the corresponding SSTART value\par
%  COST        cost per unit time to move a spike\par
%\par
%  D           the distance , as a row vector (length: #XMPsentations^2)\par
%\par
%  Copyright (c) 1999 by Daniel Reich and Jonathan Victor.\par
%  Written as a MEX file by Daniel Reich from FORTRAN code by Jonathan Victor.\par
/*=================================================================\par
 *\par
 * SPKDL.C\tab .MEX file corresponding to SPKD.M\par
 *          CALCULATES DISTANCE BETWEEN TWO SPIKE TRAINS\par
 *          IN THE SPIKE TIME METRIC BY A CONTINUUM\par
 *          MODIFICATION OF THE SELLERS ALGORITHM\par
 *\par
 *          INPUT IS ACTUALLY A SERIES OF SPIKE TRAINS WITH INDICES\par
 *\par
 *          INPUT VARIABLES:\par
 *          STIME:    LIST OF SPIKE TIMES (1...n)\par
 *          SSTART:   LIST OF TRIAL START INDICES\par
 *          SEND:     LIST OF TRIAL END INDICES\par
 *          COST:     THE COST PER UNIT TIME TO MOVE A SPIKE\par
 *\par
 *          D:      THE DISTANCE\par
 *\par
 * MAXCOST is set to 100000\par
 *\par
 * Copyright (c) 1999 by Daniel Reich and Jonathan Victor\par
 * All rights reserved.\par
 *=================================================================*/\par
/* $Revision: 1.0 $ */\par
#include "mex.h"\par
\par
/* Input Arguments */\par
\par
#define\tab STIME\tab prhs[0]\par
#define\tab SSTART\tab prhs[1]\par
#define SEND\tab prhs[2]\par
#define COST\tab prhs[3]\par
\par
\par
/* Output Arguments */\par
\par
#define\tab D\tab plhs[0]\par
\par
#if !defined(MAX)\par
#define\tab MAX(A, B)\tab ((A) > (B) ? (A) : (B))\par
#endif\par
\par
#if !defined(MIN)\par
#define\tab MIN(A, B)\tab ((A) < (B) ? (A) : (B))\par
#endif\par
\par
#define PI 3.14159265\par
#define MAXCOST 10000\par
#define EPS 0.000001\par
#define NR_END 1\par
#define FREE_ARG char*\par
\par
void nrerror(char error_text[])\par
/* Numerical Recipes standard error handler */\par
\{\par
\tab fprintf(stderr,"Numerical Recipes run-time error...\\n");\par
\tab fprintf(stderr,"%s\\n",error_text);\par
\tab fprintf(stderr,"...now exiting to system...\\n");\par
\tab exit(1);\par
\}\par
\par
double *dvector(long nl, long nh)\par
/* allocate a double vector with subscript range v[nl..nh] */\par
\{\par
\tab double *v;\par
\par
\tab v=(double *)malloc((size_t) ((nh-nl+1+NR_END)*sizeof(double)));\par
\tab if (!v) nrerror("allocation failure in dvector()");\par
\tab return v-nl+NR_END;\par
\}\par
\par
double **dmatrix(long nrl, long nrh, long ncl, long nch)\par
/* allocate a double matrix with subscript range m[nrl..nrh][ncl..nch] */\par
\{\par
\tab long i, nrow=nrh-nrl+1,ncol=nch-ncl+1;\par
\tab double **m;\par
\par
\tab /* allocate pointers to rows */\par
\tab m=(double **) malloc((size_t)((nrow+NR_END)*sizeof(double*)));\par
\tab if (!m) nrerror("allocation failure 1 in matrix()");\par
\tab m += NR_END;\par
\tab m -= nrl;\par
\par
\tab /* allocate rows and set pointers to them */\par
\tab m[nrl]=(double *) malloc((size_t)((nrow*ncol+NR_END)*sizeof(double)));\par
\tab if (!m[nrl]) nrerror("allocation failure 2 in matrix()");\par
\tab m[nrl] += NR_END;\par
\tab m[nrl] -= ncl;\par
\par
\tab for(i=nrl+1;i<=nrh;i++) m[i]=m[i-1]+ncol;\par
\par
\tab /* return pointer to array of pointers to rows */\par
\tab return m;\par
\}\par
\par
void free_dvector(double *v, long nl, long nh)\par
/* free a double vector allocated with dvector() */\par
\{\par
\tab free((FREE_ARG) (v+nl-NR_END));\par
\}\par
\par
void free_dmatrix(double **m, long nrl, long nrh, long ncl, long nch)\par
/* free a double matrix allocated by dmatrix() */\par
\{\par
\tab free((FREE_ARG) (m[nrl]+ncl-NR_END));\par
\tab free((FREE_ARG) (m+nrl-NR_END));\par
\}\par
\par
double dabs(double x)\par
\{\par
\tab if (x<0) return -x;\par
\tab else return x;\par
\}\par
\par
static void getdist(\par
\tab\tab    double\tab *d,\par
\tab\tab    unsigned int\tab nspi,\par
\tab\tab    double\tab tli[],\par
\tab\tab    unsigned int\tab nspj,\par
 \tab\tab    double\tab tlj[],\par
\tab\tab    double\tab cost\par
\tab\tab    )\par
\{\par
\tab double **scr;\par
\tab unsigned int i,j;\par
\tab      \par
\tab if (cost<EPS) \{\par
   \tab\tab *d=dabs((double)nspi-(double)nspj);\par
\tab\tab /*printf("\\n%d %d %f %f",nspi,nspj,dabs((double)nspi-(double)nspj),*d);*/\par
\tab\}\par
\tab else if (cost>=MAXCOST)\par
\tab\tab *d=nspi+nspj;\par
\tab else \{\par
\tab\tab /*     INITIALIZE MARGINS WITH COST OF ADDING A SPIKE\tab */\par
\tab\tab scr=dmatrix(0,nspi,0,nspj);\par
\tab\tab for (i=0; i<=nspi; i++)\par
\tab\tab\tab scr[i][0]=i;\par
\tab\tab for (j=0; j<=nspj; j++)\par
\tab\tab\tab scr[0][j]=j;\par
\tab\tab if (nspi!=0 && nspj!=0) \{\par
\tab\tab\tab /*     THE HEART OF THE ALGORITHM\tab */\par
\tab\tab\tab for (i=1; i<=nspi; i++)\par
\tab\tab\tab\tab for (j=1; j<=nspj; j++)\par
\tab\tab\tab\tab\tab scr[i][j]=MIN(MIN(scr[i-1][j]+1,scr[i][j-1]+1),scr[i-1][j-1]+cost*dabs(tli[i-1]-tlj[j-1]));\par
\tab\tab\}\par
\tab\tab *d=scr[nspi][nspj];\par
\tab\tab free_dmatrix(scr,0,nspi,0,nspj);\par
\tab\}\par
\tab return;\par
\}\tab\tab    \par
\par
static void getdistl(\par
\tab\tab    double *d,\par
\tab\tab    unsigned int\tab nstart,\par
\tab\tab    double\tab stime[],\par
\tab\tab    double sstart[],\par
\tab\tab    double send[],\par
\tab\tab    double\tab cost\par
\tab\tab    )\par
\{\par
\tab double *tli, *tlj;\par
\tab double dist;\par
\tab unsigned int i,j,itli,itlj;\par
\tab unsigned int nspi,nspj;\par
\tab double junk;\par
\par
\tab for (i=0; i<nstart; i++) \{\par
\tab\tab nspi=(int)(send[i]-sstart[i]+1);\par
\tab\tab if (nspi>0) \{\par
\tab\tab\tab tli=dvector(0,nspi-1);\par
\tab\tab\tab for (itli=0; itli<nspi; itli++) \{\par
\tab\tab\tab\tab tli[itli]=stime[itli+(int)sstart[i]-1];\par
\tab\tab\tab\tab /*printf("\\n%d %f",itli,tli[itli]);*/\par
\tab\tab\tab\}\par
\tab\tab\}\par
\tab\tab for (j=i+1; j<nstart; j++) \{\par
\tab\tab\tab nspj=(int)(send[j]-sstart[j]+1);\par
\tab\tab\tab /*printf("\\nnspi=%d\\tnspj=%d",nspi,nspj);*/\par
\tab\tab\tab if (nspi>0 && nspj>0) \{\par
\tab\tab\tab\tab tlj=dvector(0,nspj-1);\par
\tab\tab\tab\tab for (itlj=0; itlj<nspj; itlj++) \{\par
\tab\tab\tab\tab\tab tlj[itlj]=stime[itlj+(int)sstart[j]-1];\par
\tab\tab\tab\tab\tab /*printf("\\n%d %f",itlj,tlj[itlj]);*/\par
\tab\tab\tab\tab\}\par
\tab\tab\tab\tab getdist(&dist,nspi,tli,nspj,tlj,cost);\par
\tab\tab\tab\tab /*printf("\\t%f",dist);*/\par
\tab\tab\tab\tab free_dvector(tlj,0,nspj-1);\par
\tab\tab\tab\}\par
\tab\tab\tab if (nspi==0 && nspj>0) dist=nspj;\par
\tab\tab\tab else if (nspj==0 && nspi>0) dist=nspi;\par
\tab\tab\tab else if (nspj==0 && nspi==0) dist=0;\par
\tab\tab\tab /*printf("\\n%d %d %d %f",i,j,i*nstart+j,dist);*/\par
\tab\tab\tab d[i*nstart+j]=d[j*nstart+i]=dist;\par
\tab\tab\}\par
\tab\tab if (nspi>0) free_dvector(tli,0,nspi-1);\par
\tab\}\par
\tab return;\par
\}\par
\par
void mexFunction( int nlhs, mxArray *plhs[], \par
\tab\tab   int nrhs, const mxArray*prhs[] )\par
     \par
\{ \par
    double *stime, cost; \par
\tab double *sstart, *send;\par
    double *d; \par
    unsigned int nspikes,nstart,nend,junk; \par
    \par
    /* Check for proper number of arguments */\par
    \par
    if (nrhs != 4) \{ \par
\tab mexErrMsgTxt("Four input arguments required."); \par
    \} else if (nlhs > 1) \{\par
\tab mexErrMsgTxt("Too many output arguments."); \par
    \} \par
    \par
    /* Check the dimensions of STIME.  STIME can be n X 1 or 1 X n. */ \par
    \par
    nspikes = mxGetM(STIME); \par
    junk = mxGetN(STIME);\par
    if (!mxIsDouble(STIME) || (MIN(nspikes,junk) > 1)) \{ \par
\tab mexErrMsgTxt("SPKDL requires that STIME be a row or column vector."); \par
    \} \par
\tab nspikes=MAX(nspikes,junk);\par
\tab\par
    nstart = mxGetM(SSTART); \par
    junk = mxGetN(SSTART);\par
\tab nstart = MAX(nstart,junk);\par
    nend = mxGetM(SEND); \par
    junk = mxGetN(SEND);\par
\tab nend= MAX(nend,junk); \par
    \par
    if (nstart != nend) \{ \par
\tab mexErrMsgTxt("SPKDL requires that SSTART and SEND have the same dimensions."); \par
    \} \par
\par
    cost = mxGetM(COST); \par
    junk = mxGetN(COST);\par
    if (!mxIsDouble(COST) || (MAX(cost,junk) != 1) || (MIN(cost,junk) != 1)) \{ \par
\tab mexErrMsgTxt("SPKD requires that COST be a scalar."); \par
    \} \par
\par
    /* Create a matrix for the return argument */ \par
    D = mxCreateDoubleMatrix(nstart*nstart, 1, mxREAL); \par
    \par
    /* Assign pointers to the various parameters */ \par
    d = mxGetPr(D);\par
    \par
    stime = mxGetPr(STIME); \par
    sstart = mxGetPr(SSTART);\par
\tab send = mxGetPr(SEND);\par
\tab cost = mxGetScalar(COST);\par
        \par
    /* Do the actual computations in a subroutine */\par
\tab getdistl(d,nstart,stime,sstart,send,cost);\par
\tab\par
    return;\par
\}\par
}
 